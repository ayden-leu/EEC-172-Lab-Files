
/* These functions are based on the Arduino test program at
*  https://github.com/adafruit/Adafruit-SSD1351-library/blob/master/examples/test/test.ino
*
*  You can use these high-level routines to implement your
*  test program.
*/

// TODO Configure SPI port and use these libraries to implement
// an OLED test program. See SPI example program.

#include "oled_test.h"

#include "Adafruit_GFX.h"
#include "Adafruit_SSD1351.h"
#include "i2c_if.h"

//*****************************************************************************
//  function delays 3*ulCount cycles
static void delay(unsigned long ulCount){
    int i;
    do{
        ulCount--;
        for (i=0; i<65535; i++);
    }while(ulCount);
}

#define BMA222_ADDR   0x18
#define REG_ACC_X     0x03
#define REG_ACC_Y     0x05

#define DEADZONE      1
#define SCALE_SHIFT   3

#define REG_CHIP_ID 0x00

static int ball_x, ball_y;
static int old_x, old_y;




static unsigned char bma222_read_u8(unsigned char reg)
{
    unsigned char raw = 0xAA; // sentinel
    int ret;

    ret = I2C_IF_Write(BMA222_ADDR, &reg, 1, 0);
    if (ret != 0) return 0xEE;   // write failed

    ret = I2C_IF_Read(BMA222_ADDR, &raw, 1);
    if (ret != 0) return 0xEF;   // read failed

    return raw;
}


// clamp helper
static int clamp_int(int v, int lo, int hi){
    if (v < lo) return lo;
    if (v > hi) return hi;
    return v;
}

static void clampBall(void){
    ball_x = clamp_int(ball_x, BALL_RADIUS, (OLED_WIDTH  - 1) - BALL_RADIUS);
    ball_y = clamp_int(ball_y, BALL_RADIUS, (OLED_HEIGHT - 1) - BALL_RADIUS);
}

// draw/erase helpers
static void eraseBall(int x, int y){
    fillCircle(x, y, BALL_RADIUS, BLACK);
}
static void drawBall(int x, int y){
    fillCircle(x, y, BALL_RADIUS, BALL_COLOR);
}

static signed char bma222_read_s8(unsigned char reg){
    unsigned char raw = 0;

    // Set register pointer (no stop bit), then read 1 byte
    I2C_IF_Write(BMA222_ADDR, &reg, 1, 0);
    I2C_IF_Read(BMA222_ADDR, &raw, 1);

    return (signed char)raw;   // two’s complement -> signed
}

static int accel_to_step(int a){
    int d = 0;

    if (a > DEADZONE) {
        d = (a - DEADZONE) >> SCALE_SHIFT;
        if (d < 1) d = 1;
    } else if (a < -DEADZONE) {
        d = (a + DEADZONE) >> SCALE_SHIFT;
        if (d > -1) d = -1;
    } else {
        d = 0;
    }
    return d;
}

// Roll: move left/right using X axis
void ballRoll(void){
    int ax = (int)bma222_read_s8(REG_ACC_X);
    int dx = accel_to_step(ax);
    ball_x += dx;
}



// Pitch: move up/down using Y axis
void ballPitch(void){
    int ay = (int)bma222_read_s8(REG_ACC_Y);
    int dy = accel_to_step(ay);


    // ball_y += dy; or ball_y -= dy;
    ball_y += dy;
}



void checkoffInit(void){
    fillScreen(BLACK);

    unsigned char id18 = bma222_read_u8(REG_CHIP_ID);

    // Draw the chip-id as color-coded result:
    // If id18 is 0xEE/0xEF -> I2C fail
    // If id18 is 0x00 or 0xFF -> wrong device/address or not responding
    if (id18 == 0xEE || id18 == 0xEF) {
        fillScreen(RED);   // I2C read/write failed
    } else if (id18 == 0x00 || id18 == 0xFF) {
        fillScreen(YELLOW); // device not responding / wrong address
    } else {
        fillScreen(GREEN);  // sensor responded
    }

    ball_x = OLED_WIDTH / 2;
    ball_y = OLED_HEIGHT / 2;
    drawBall(ball_x, ball_y);
}

void checkoffLoop(void){
    // Save old position
    old_x = ball_x;
    old_y = ball_y;

    // Update position from accelerometer
    ballRoll();
    ballPitch();
    clampBall();

    // Only redraw if position changed (reduces blinking)
    if (ball_x != old_x || ball_y != old_y){
        eraseBall(old_x, old_y);
        drawBall(ball_x, ball_y);
    }

    delay(5);
}



















